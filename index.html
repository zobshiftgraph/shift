<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shift Visualizer & Request Processor</title>
    <style>
        :root {
            --bg-color: #f4f4f9;
            --panel-bg: #ffffff;
            --text-color: #333;
            --accent-color: #3b82f6;
            --grid-line-color: #e5e7eb;
            --bar-color: #60a5fa;       /* Standard Blue */
            --bar-trainee: #a855f7;     /* Trainee Purple */
            --bar-leave: #9ca3af;       /* Grey */
            --bar-tos: #22c55e;         /* Green */
            --bar-hover: #2563eb;
            --danger-color: #dc2626;    /* Darker Red */
            --warning-color: #d97706;   /* Amber */
            --pending-color: #d35400; 
            --denied-color: #c0392b;    
            --last-hour-color: #fcd34d; 
            
            --training-stripe: repeating-linear-gradient(
                45deg,
                #60a5fa,
                #60a5fa 10px,
                #a855f7 10px,
                #a855f7 20px
            );
        }

        * { box-sizing: border-box; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }

        body {
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
        }

        header {
            padding: 10px 20px;
            background: var(--panel-bg);
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
            gap: 15px;
            height: 60px;
            flex-shrink: 0;
            overflow: visible; 
            position: relative; 
            z-index: 1000;      
        }

        h2 { font-size: 1.2rem; margin-right: 10px; white-space: nowrap;}

        /* STATS STYLING */
        .stats-container {
            display: flex;
            gap: 15px;
            background: #f3f4f6;
            padding: 5px 15px;
            border-radius: 20px;
            border: 1px solid #ddd;
            font-size: 0.9rem;
            font-weight: 800;
            margin-right: auto; 
            white-space: nowrap;
        }
        .stat-box { display: flex; align-items: center; color: black; }
        .stat-warning { color: var(--warning-color) !important; } 
        .stat-danger { color: var(--danger-color) !important; }

        input[type="date"] { padding: 5px; border: 1px solid #ccc; border-radius: 4px; }

        button {
            padding: 6px 12px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        button:hover { opacity: 0.9; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; }
        button.secondary { background-color: #6b7280; }
        button.action-btn { background-color: #0d9488; } 
        button.smart-btn { background-color: #8b5cf6; font-weight: bold;} 

        .menu-container { position: relative; }
        .menu-dropdown {
            position: absolute;
            top: 100%; left: 0; background: white; border: 1px solid #ccc; border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: none; flex-direction: column;
            min-width: 150px; z-index: 2000; margin-top: 5px;
        }
        .menu-dropdown button {
            background: none; color: #333; text-align: left; padding: 10px 15px;
            border-radius: 0; border-bottom: 1px solid #eee;
        }
        .menu-dropdown button:last-child { border-bottom: none; }

        .main-container { display: flex; flex: 1; overflow: hidden; height: calc(100vh - 60px); }

        .graph-container {
            flex: 1; display: flex; flex-direction: column; border-right: 1px solid #ccc;
            position: relative; overflow: hidden; background: #fff;
        }

        .timeline-header { height: 40px; position: relative; border-bottom: 1px solid #ccc; background: #f9fafb; flex-shrink: 0; }
        .time-label { position: absolute; bottom: 5px; font-size: 0.75rem; font-weight: 500; transform: translateX(-50%); color: #555; }

        .count-header { height: 25px; position: relative; border-bottom: 1px solid #ccc; background: #fff; flex-shrink: 0; }
        .count-label {
            position: absolute; top: 0; bottom: 0; display: flex; align-items: center; justify-content: center;
            font-size: 0.75rem; font-weight: bold; color: #3b82f6; border-right: 1px dashed #eee;
        }

        /* SHADING CLASSES */
        .count-good { background-color: #86efac !important; color: #14532d !important; } 
        .count-bad { background-color: #fca5a5 !important; color: #7f1d1d !important; } 
        .count-warning { background-color: #fef08a !important; color: #854d0e !important; } 

        .graph-body { flex: 1; position: relative; display: flex; flex-direction: column; justify-content: flex-start; overflow-y: hidden; }

        .grid-lines { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; }
        .grid-line { position: absolute; top: 0; bottom: 0; width: 1px; background-color: var(--grid-line-color); }

        .current-time-line {
            position: absolute; top: 0; bottom: 0; width: 2px; background-color: var(--danger-color);
            z-index: 50; pointer-events: none; box-shadow: 0 0 4px rgba(239, 68, 68, 0.6);
        }
        .current-time-line::after {
            content: attr(data-time); 
            position: absolute; top: 2px; left: 4px; font-size: 0.65rem;
            background: var(--danger-color); color: white; padding: 1px 3px; border-radius: 2px;
            white-space: nowrap;
        }

        .shift-row { position: relative; width: 100%; flex: 1; min-height: 0; display: flex; align-items: center; border-bottom: 1px solid #f3f4f6; }

        .bar-segment {
            position: absolute; height: 70%; border-radius: 3px; border: 1px solid rgba(0,0,0,0.1);
            display: flex; align-items: center; justify-content: center; color: white; font-size: 0.75rem;
            padding: 0 2px; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.1); overflow: hidden; transition: all 0.2s;
        }
        .shift-bar { background-color: var(--bar-color); z-index: 5; position: absolute; }
        .shift-bar:hover { z-index: 10; background-color: var(--bar-hover); height: 85%; }
        
        .shift-bar.bar-over { background-color: #e5e7eb !important; border-color: #d1d5db !important; color: #888 !important; opacity: 0.8; }
        .shift-bar.bar-over .last-hour-indicator { display: none; }

        .shift-bar.trainee { background-color: var(--bar-trainee); border-color: #7e22ce; }
        .leave-bar { background-color: var(--bar-leave); z-index: 20; border-color: #6b7280; }
        .leave-bar:hover { z-index: 25; height: 85%; }
        .tos-bar { background-color: var(--bar-tos); z-index: 15; border-color: #16a34a; }
        .tos-bar:hover { z-index: 25; height: 85%; }

        .preview-highlight { border: 3px solid #22c55e !important; box-shadow: 0 0 10px rgba(34, 197, 94, 0.6); z-index: 100 !important; }

        .last-hour-indicator {
            position: absolute; top: 0; bottom: 0; background-color: var(--last-hour-color);
            opacity: 0.6; z-index: 1; pointer-events: none;
            border-left: 1px solid rgba(255,255,255,0.4); border-right: 1px solid rgba(255,255,255,0.4);
        }
        .training-overlap-indicator {
            position: absolute; top: 0; bottom: 0; background: var(--training-stripe);
            z-index: 2; pointer-events: none;
            border-left: 1px solid rgba(255,255,255,0.4); border-right: 1px solid rgba(255,255,255,0.4);
        }

        .wx-badge {
            position: absolute; 
            top: 0; bottom: 0; display: flex; align-items: center;
            color: white; font-size: 0.7rem; font-weight: 900; z-index: 20;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5); white-space: nowrap;
        }

        .bar-text-container {
            position: absolute; top: 0; height: 100%; z-index: 8; display: flex; align-items: center; justify-content: center;
            gap: 5px; text-shadow: 0 1px 3px rgba(0,0,0,0.7); white-space: nowrap; overflow: hidden;
            text-overflow: ellipsis; max-width: 100%; width: 100%; left: 0;
        }
        .bar-initials { font-weight: 900; font-size: 0.85rem; letter-spacing: 0.5px; }
        .bar-times { font-weight: 500; font-size: 0.7rem; opacity: 0.95; }

        .leave-bar .bar-text-container, .tos-bar .bar-text-container { flex-direction: column; align-items: center; justify-content: center; line-height: 0.9; gap: 0; width: 100%; }
        .leave-bar .bar-initials, .tos-bar .bar-initials { font-size: 0.7rem; }
        .leave-bar .bar-times, .tos-bar .bar-times { font-size: 0.6rem; }

        .list-container {
            width: 280px; min-width: 250px; max-width: 320px; background: var(--panel-bg);
            display: flex; flex-direction: column; overflow: hidden; border-left: 1px solid #ccc;
        }

        .list-header { padding: 10px; font-weight: bold; border-bottom: 1px solid #eee; background: #f3f4f6; font-size: 0.9rem; }
        .employee-list { flex: 1; overflow-y: auto; padding: 10px; }

        .employee-card {
            display: flex; justify-content: space-between; align-items: flex-start; padding: 8px;
            border: 1px solid #eee; border-radius: 6px; margin-bottom: 6px; background: #fff; transition: background 0.2s;
        }
        .employee-card.trainee-card { background-color: #f3e8ff; border-color: #d8b4fe; }
        .employee-card:hover { background-color: #f9fafb; }

        .card-active { background-color: #dcfce7 !important; border-left: 4px solid #22c55e !important; }
        .card-over { background-color: #f3f4f6 !important; opacity: 0.6; color: #666; }
        
        .emp-info { display: flex; flex-direction: column; overflow: hidden; width: 65%; }
        .emp-name { font-weight: 600; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .emp-time { font-size: 0.75rem; color: #666; }
        .emp-notes { font-size: 0.7rem; color: #555; font-style: italic; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .cic-tag { font-size: 0.65rem; color: #d97706; font-weight: bold; margin-left: 5px; background: #fef3c7; padding: 1px 3px; border-radius: 3px; }

        .tag-row { margin-top: 3px; display: flex; flex-wrap: wrap; gap: 3px; }
        .tag-badge { font-size: 0.65rem; padding: 1px 4px; border-radius: 3px; border: 1px solid transparent; font-weight: 500; }
        .tag-leave { background: #f3f4f6; color: #4b5563; border-color: #d1d5db; }
        .tag-tos { background: #dcfce7; color: #166534; border-color: #bbf7d0; }

        .emp-actions { display: flex; gap: 3px; margin-top: 2px; }
        .btn-icon { padding: 4px 8px; font-size: 0.75rem; margin-left: 2px; border-radius: 3px; border:none; color:white; cursor:pointer;}
        .btn-edit { background-color: #f59e0b; }
        .btn-del { background-color: var(--danger-color); }

        .trainer-dropdown { margin-top: 4px; padding: 2px; font-size: 0.75rem; border: 1px solid #d8b4fe; border-radius: 4px; background: #fff; width: 100%; max-width: 100%; cursor: pointer; }

        .pending-container { border-top: 2px solid #ccc; background-color: #fafafa; padding: 0; max-height: 35%; overflow-y: auto; display: none; }
        .pending-header { padding: 8px 10px; background: #fff3e0; font-weight: bold; font-size: 0.85rem; color: #d35400; border-bottom: 1px solid #eee; }
        .pending-list { list-style: none; padding: 10px; margin: 0; }
        
        .pending-item {
            background: #fff; border: 1px solid #ddd; border-left-width: 4px; padding: 8px;
            margin-bottom: 5px; border-radius: 3px; font-size: 0.75rem;
            display: flex; justify-content: space-between; align-items: center;
            cursor: pointer; transition: transform 0.1s, box-shadow 0.1s;
        }
        .pending-item:hover { transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .pending-item.active-preview { background-color: #dcfce7; border-left-color: #22c55e !important; border-color: #86efac; }
        
        .status-pending { border-left-color: var(--pending-color); }
        .status-denied { border-left-color: var(--denied-color); }
        .status-badge-req { color: white; padding: 2px 5px; border-radius: 3px; font-size: 0.65rem; text-transform: uppercase; font-weight: bold; }
        .bg-pending { background-color: var(--pending-color); }
        .bg-denied { background-color: var(--denied-color); }
        .req-info { display: flex; flex-direction: column; width: 85%; }
        .req-delete { width: 10%; text-align: right; color: #aaa; font-size: 1.1em; }
        .req-delete:hover { color: #c0392b; }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal { background: white; padding: 20px; border-radius: 8px; width: 450px; max-width: 90%; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .modal h3 { margin-bottom: 15px; }
        .modal textarea { width: 100%; height: 150px; margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; font-family: monospace; resize: vertical; }
        
        .form-row { display: flex; gap: 10px; margin-bottom: 10px; }
        .form-group { flex: 1; margin-bottom: 12px; position: relative; }
        .form-group label { display: block; font-size: 0.85rem; margin-bottom: 4px; font-weight: 500;}
        .form-group input, .form-group select { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        .form-group input[readonly] { background-color: #f3f4f6; color: #666; cursor: not-allowed; }
        
        .section-title { font-size: 0.8rem; text-transform: uppercase; color: #666; border-bottom: 1px solid #eee; margin-bottom: 10px; padding-bottom: 4px; font-weight: bold; margin-top: 15px; }
        
        .input-wrapper { position: relative; display: flex; align-items: center; }
        .btn-clear {
            position: absolute; right: 5px; top: 50%; transform: translateY(-50%);
            background: #e5e7eb; color: #555; border: none; font-size: 0.7rem;
            width: 20px; height: 20px; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer;
        }
        .btn-clear:hover { background: #d1d5db; }
        
        .modal-tag-container { min-height: 24px; margin-top: 6px; }
        .modal-tag { display: inline-flex; align-items: center; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: bold; gap: 5px; margin-right: 5px;}
        .modal-tag.leave { background: #f3f4f6; color: #4b5563; border: 1px solid #d1d5db; }
        .modal-tag.tos { background: #dcfce7; color: #166534; border: 1px solid #bbf7d0; }
        .tag-remove { cursor: pointer; font-weight: 900; color: inherit; opacity: 0.6; font-size: 0.9rem;}
        .tag-remove:hover { opacity: 1; }

        .modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; }

        .manage-list { list-style: none; max-height: 300px; overflow-y: auto; border: 1px solid #eee; padding: 5px; border-radius: 4px; margin-top: 10px; }
        .manage-item { display: flex; justify-content: space-between; padding: 8px; border-bottom: 1px solid #eee; align-items: center; }
        .manage-item:last-child { border-bottom: none; }
        .manage-input-group { display: flex; gap: 5px; margin-top: 15px; }

        .checkbox-wrapper { display: none; align-items: center; gap: 8px; margin-top: 5px; height: 100%; padding-bottom: 5px; }
        .checkbox-wrapper input { width: auto; }
        .checkbox-wrapper label { margin: 0; font-weight: 500; font-size: 0.85rem; cursor: pointer; color: #333; }
    </style>
</head>
<body>

<header>
    <div class="menu-container">
        <button onclick="toggleMenu()" class="secondary">Menu ‚ñº</button>
        <div class="menu-dropdown" id="menuDropdown">
            <button onclick="openManageModal('trainer')">Trainer List</button>
            <button onclick="openManageModal('trainee')">Trainee List</button>
        </div>
    </div>
    <h2>Shift Visualizer</h2>
    
    <div class="stats-container">
        <span class="stat-box day">Day: 0</span>
        <span class="stat-box eve">Eve: 0</span>
    </div>

    <button onclick="openPreDutyModal()">Paste Pre-Duty WX</button>
    <button onclick="undo()" id="btnUndo" disabled title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
    <button onclick="redo()" id="btnRedo" disabled title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
    
    <div class="date-nav">
        <button class="nav-btn" onclick="changeDate(-1)" title="Previous Day">‚Äπ</button>
        <input type="date" id="datePicker">
        <button class="nav-btn" onclick="changeDate(1)" title="Next Day">‚Ä∫</button>
    </div>
    <button class="smart-btn" onclick="initiateSmartPaste()">Smart Paste</button>
    <button class="secondary" onclick="clearData()">Clear Day</button>
</header>

<div class="main-container">
    <div class="graph-container">
        <div class="timeline-header" id="timelineHeader"></div>
        <div class="count-header" id="countHeader"></div>
        <div class="grid-lines" id="gridLines"></div>
        <div id="currentTimeLine" class="current-time-line" style="display:none;"></div>
        <div class="graph-body" id="graphBody"></div>
    </div>

    <div class="list-container">
        <div class="list-header">Employee List</div>
        <div class="employee-list" id="employeeList"></div>
        <div class="pending-container" id="pendingContainer">
            <div class="pending-header">Pending / Denied</div>
            <ul id="pendingList" class="pending-list"></ul>
        </div>
    </div>
</div>

<div class="modal-overlay" id="smartPasteModal">
    <div class="modal">
        <h3>Smart Import Data</h3>
        <p style="font-size:0.8rem; color:#666; margin-bottom:10px;">Paste data from the "Magic Bookmark", Schedule, Requests, or Pre-Duty WX.</p>
        <textarea id="smartPasteInput" placeholder="Paste anything here..."></textarea>
        <div class="modal-actions">
            <button class="secondary" onclick="closeModal('smartPasteModal')">Cancel</button>
            <button class="smart-btn" onclick="processSmartPaste()">Import</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="editModal">
    <div class="modal">
        <h3>Edit Shift</h3>
        <input type="hidden" id="editId">
        <div class="form-row">
            <div class="form-group" style="flex: 1;"><label>Name</label><input type="text" id="editName" readonly></div>
            <div class="form-group" style="flex: 1; display: flex; align-items: flex-end; flex-direction: column; justify-content: flex-end;">
                <div class="checkbox-wrapper" style="display:flex; margin-bottom: 5px;">
                    <input type="checkbox" id="editPreDutyWx"><label for="editPreDutyWx">Pre-Duty WX</label>
                </div>
                <div class="checkbox-wrapper" id="staffingCheckboxWrapper">
                    <input type="checkbox" id="editStaffing"><label for="editStaffing">Count for Staffing</label>
                </div>
            </div>
        </div>
        <div class="form-group" id="trainerSelectWrapper" style="display:none;">
            <label>Assigned Trainer</label><select id="editAssignedTrainer"><option value="">-- No Trainer --</option></select>
        </div>
        <div class="section-title">Main Shift</div>
        <div class="form-row">
            <div class="form-group"><label>Start (HHMM)</label><input type="text" id="editStart" placeholder="0600"></div>
            <div class="form-group"><label>Duration (Hours)</label><input type="number" id="editDuration" placeholder="8" step="0.25"></div>
        </div>
        <div class="form-group"><label>Notes</label><div class="input-wrapper"><input type="text" id="editNotes" placeholder="Shift notes..."><button class="btn-clear" onclick="clearInput('editNotes')" title="Clear">‚úï</button></div></div>
        
        <div class="section-title">Leave (Grey)</div>
        <div class="form-group">
            <label>Range (e.g. 1300-1400)</label>
            <div class="input-wrapper">
                <input type="text" id="editLeaveRange" placeholder="HHMM-HHMM" onkeydown="handleTagKey(event, 'leave')">
                <button class="btn-clear" onclick="manualAddTag('leave')" title="Add Tag">Ôºã</button>
            </div>
            <div id="previewLeave" class="modal-tag-container"></div>
        </div>

        <div class="section-title">Time Outside Shift (Green)</div>
        <div class="form-group">
            <label>Range (e.g. 0300-0400)</label>
            <div class="input-wrapper">
                <input type="text" id="editTosRange" placeholder="HHMM-HHMM" onkeydown="handleTagKey(event, 'tos')">
                <button class="btn-clear" onclick="manualAddTag('tos')" title="Add Tag">Ôºã</button>
            </div>
            <div id="previewTos" class="modal-tag-container"></div>
        </div>

        <div class="modal-actions"><button class="secondary" onclick="closeModal('editModal')">Cancel</button><button onclick="saveEdit()">Save</button></div>
    </div>
</div>

<div class="modal-overlay" id="manageModal">
    <div class="modal">
        <h3 id="manageTitle">Manage List</h3>
        <ul id="manageListEl" class="manage-list"></ul>
        <div class="manage-input-group"><input type="text" id="manageInput" placeholder="Add Initials/Name..."><button onclick="addListItem()">Add</button></div>
        <div class="modal-actions"><button class="secondary" onclick="closeModal('manageModal')">Close</button></div>
    </div>
</div>

<div class="modal-overlay" id="pasteModal">
    <div class="modal">
        <h3>Paste Schedule Data</h3>
        <p style="font-size:0.8rem; color:#666; margin-bottom:10px;">Paste column data below.</p>
        <textarea id="pasteInput" placeholder="Paste data here..."></textarea>
        <div class="modal-actions">
            <button class="secondary" onclick="closeModal('pasteModal')">Cancel</button>
            <button onclick="processPaste()">Visualize</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="preDutyModal">
    <div class="modal">
        <h3>Paste Pre-Duty WX Data</h3>
        <p style="font-size:0.8rem; color:#666; margin-bottom:10px;">Paste log data (8kj) or just initials (kj).</p>
        <textarea id="preDutyInput" placeholder="Paste text here..."></textarea>
        <div class="modal-actions">
            <button class="secondary" onclick="closeModal('preDutyModal')">Cancel</button>
            <button onclick="processPreDuty()">Process</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="requestModal">
    <div class="modal">
        <h3>Paste Request Data</h3>
        <p style="font-size:0.8rem; color:#666; margin-bottom:10px;">Paste the 8 columns: CPC, TYPE, FROM, TO, WITH, STATUS, INI, DATE.</p>
        <textarea id="requestInput" placeholder="Paste request table here..."></textarea>
        <div class="modal-actions">
            <button class="secondary" onclick="closeModal('requestModal')">Cancel</button>
            <button onclick="processRequests()">Process</button>
        </div>
    </div>
</div>

<script>
    const START_HOUR = 4; const TOTAL_MINUTES = 24 * 60; 
    const today = new Date();
    let currentDate = today.getFullYear() + '-' + String(today.getMonth()+1).padStart(2,'0') + '-' + String(today.getDate()).padStart(2,'0');
    let shifts = [];
    let requests = []; 
    let previewBackups = new Map(); 
    let previewTimers = new Map(); 
    let trainers = JSON.parse(localStorage.getItem('app_trainers')) || [];
    let trainees = JSON.parse(localStorage.getItem('app_trainees')) || [];
    let currentManageType = ''; 

    // --- UNDO/REDO STATE ---
    let undoStack = [];
    let redoStack = [];
    const MAX_HISTORY = 50;

    function pushHistory() {
        const state = JSON.stringify(shifts);
        undoStack.push(state);
        if (undoStack.length > MAX_HISTORY) undoStack.shift();
        redoStack = []; 
        updateUndoRedoButtons();
    }

    function undo() {
        if (undoStack.length === 0) return;
        const current = JSON.stringify(shifts);
        redoStack.push(current);
        const prev = undoStack.pop();
        shifts = JSON.parse(prev);
        saveData(false); 
        updateUndoRedoButtons();
    }

    function redo() {
        if (redoStack.length === 0) return;
        const current = JSON.stringify(shifts);
        undoStack.push(current);
        const next = redoStack.pop();
        shifts = JSON.parse(next);
        saveData(false); 
        updateUndoRedoButtons();
    }

    function updateUndoRedoButtons() {
        document.getElementById('btnUndo').disabled = undoStack.length === 0;
        document.getElementById('btnRedo').disabled = redoStack.length === 0;
    }

    document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
    });

    document.addEventListener('DOMContentLoaded', () => {
        const dateInput = document.getElementById('datePicker');
        dateInput.value = currentDate;
        dateInput.addEventListener('change', (e) => { 
            currentDate = e.target.value; 
            undoStack = []; redoStack = []; updateUndoRedoButtons();
            loadData(); loadRequests(); updateCurrentTime(); 
        });
        generateTimeline(); loadData(); loadRequests(); updateCurrentTime(); setInterval(updateCurrentTime, 60000);
        document.addEventListener('click', (e) => { if (!e.target.closest('.menu-container')) document.getElementById('menuDropdown').style.display = 'none'; });
        document.getElementById('manageInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') addListItem(); });
    });

    function changeDate(days) {
        const dateInput = document.getElementById('datePicker');
        if (!dateInput.value) return;
        const parts = dateInput.value.split('-');
        const current = new Date(parts[0], parts[1] - 1, parts[2]); 
        current.setDate(current.getDate() + days);
        const y = current.getFullYear();
        const m = String(current.getMonth() + 1).padStart(2, '0');
        const d = String(current.getDate()).padStart(2, '0');
        dateInput.value = `${y}-${m}-${d}`;
        dateInput.dispatchEvent(new Event('change'));
    }

    // --- SAVE/LOAD REQUESTS ---
    function loadRequests() {
        const stored = localStorage.getItem('requests_' + currentDate);
        requests = stored ? JSON.parse(stored) : [];
        renderRequests();
    }
    function saveRequests() {
        localStorage.setItem('requests_' + currentDate, JSON.stringify(requests));
    }
    function renderRequests() {
        const listEl = document.getElementById('pendingList');
        const container = document.getElementById('pendingContainer');
        listEl.innerHTML = '';
        
        if (requests.length === 0) {
            container.style.display = 'none';
            return;
        }
        
        container.style.display = 'block';
        
        requests.forEach((req, idx) => {
            const li = document.createElement('li');
            const isPending = req.status.toLowerCase().includes('pending');
            li.className = `pending-item ${isPending ? 'status-pending' : 'status-denied'}`;
            
            li.innerHTML = `
                <div class="req-info" onclick="triggerPreview(${idx})">
                    <span><strong>${req.cpc}</strong>: ${req.type} ${req.details}</span>
                    <span class="status-badge-req ${isPending ? 'bg-pending' : 'bg-denied'}" style="width: fit-content; margin-top:3px;">${req.status}</span>
                </div>
                <div class="req-delete" onclick="deleteRequest(${idx})" title="Remove request">üóë</div>
            `;
            listEl.appendChild(li);
        });
    }
    
    function deleteRequest(idx) {
        const req = requests[idx];
        const domItem = document.getElementById('pendingList').children[idx];
        if (domItem && domItem.classList.contains('active-preview')) {
            triggerPreview(idx); 
        }
        requests.splice(idx, 1);
        saveRequests();
        renderRequests();
    }

    window.triggerPreview = function(idx) {
        const req = requests[idx];
        const li = document.getElementById('pendingList').children[idx];
        const isTos = ['XTE', 'CTE', 'OT'].some(t => req.type.toUpperCase().includes(t));
        toggleRequestPreview(li, req.cpc, req.isShiftChg, req.cleanFrom, req.cleanTo, isTos);
    };

    function toggleMenu() { const m = document.getElementById('menuDropdown'); m.style.display = m.style.display === 'flex' ? 'none' : 'flex'; }
    function openManageModal(type) {
        currentManageType = type;
        document.getElementById('manageTitle').innerText = type === 'trainer' ? 'Manage Trainer List' : 'Manage Trainee List';
        renderManageList();
        document.getElementById('menuDropdown').style.display = 'none';
        document.getElementById('manageModal').style.display = 'flex';
        setTimeout(() => document.getElementById('manageInput').focus(), 50);
    }
    function renderManageList() {
        const list = currentManageType === 'trainer' ? trainers : trainees;
        const ul = document.getElementById('manageListEl'); ul.innerHTML = '';
        if(list.length === 0) { ul.innerHTML = '<li style="padding:10px; color:#999; text-align:center;">No items yet.</li>'; return; }
        list.forEach((item, idx) => {
            const li = document.createElement('li'); li.className = 'manage-item';
            li.innerHTML = `<span>${item}</span><button class="btn-icon btn-del" onclick="deleteListItem(${idx})">X</button>`;
            ul.appendChild(li);
        });
    }
    function addListItem() {
        const val = document.getElementById('manageInput').value.trim(); if(!val) return;
        if(currentManageType === 'trainer') { trainers.push(val); localStorage.setItem('app_trainers', JSON.stringify(trainers)); } 
        else { trainees.push(val); localStorage.setItem('app_trainees', JSON.stringify(trainees)); }
        document.getElementById('manageInput').value = ''; renderManageList(); render();
    }
    function deleteListItem(idx) {
        if(currentManageType === 'trainer') { trainers.splice(idx, 1); localStorage.setItem('app_trainers', JSON.stringify(trainers)); } 
        else { trainees.splice(idx, 1); localStorage.setItem('app_trainees', JSON.stringify(trainees)); }
        renderManageList(); render(); 
    }

    function generateTimeline() {
        const header = document.getElementById('timelineHeader');
        const countHeader = document.getElementById('countHeader');
        const grid = document.getElementById('gridLines');
        header.innerHTML = ''; countHeader.innerHTML = ''; grid.innerHTML = '';
        for (let i = 0; i <= 24; i++) {
            let hour = START_HOUR + i; let displayHour = hour % 24; 
            let labelText = String(displayHour).padStart(2, '0') + ":00"; let pct = (i / 24) * 100;
            if (i < 24) { 
                const line = document.createElement('div'); line.className = 'grid-line'; line.style.left = pct + '%'; grid.appendChild(line);
                const countSlot = document.createElement('div'); countSlot.className = 'count-label'; countSlot.style.left = pct + '%'; countSlot.style.width = (100/24) + '%'; countSlot.id = 'count-' + i; countSlot.innerText = '0'; countHeader.appendChild(countSlot);
            }
            const label = document.createElement('div'); label.className = 'time-label'; label.innerText = labelText; label.style.left = pct + '%'; header.appendChild(label);
        }
    }
    
    // --- UPDATED TIME & STATUS LOGIC ---
    function updateCurrentTime() {
        const now = new Date(); const line = document.getElementById('currentTimeLine');
        const pickerValue = document.getElementById('datePicker').value; if (!pickerValue) return;
        const [pYear, pMonth, pDay] = pickerValue.split('-').map(Number);
        const startBoundary = new Date(pYear, pMonth - 1, pDay, START_HOUR, 0, 0, 0);
        const endBoundary = new Date(startBoundary); endBoundary.setDate(endBoundary.getDate() + 1);
        
        // Update Time Line
        if (now >= startBoundary && now < endBoundary) {
            const pct = ((now - startBoundary) / (endBoundary - startBoundary)) * 100;
            line.style.left = pct + '%'; 
            line.style.display = 'block';
            const h = String(now.getHours()).padStart(2, '0');
            const m = String(now.getMinutes()).padStart(2, '0');
            line.setAttribute('data-time', `${h}:${m}`);
        } else { 
            line.style.display = 'none'; 
        }
        
        // Also update Employee Status Colors
        updateEmployeeStatuses(now, startBoundary, endBoundary);
    }

    function updateEmployeeStatuses(now, startBoundary, endBoundary) {
        let currentOffset = -1;
        if (now >= startBoundary && now < endBoundary) {
            currentOffset = (now - startBoundary) / 1000 / 60; 
        } else if (now > endBoundary) {
            currentOffset = 9999; 
        } else {
            currentOffset = -1; 
        }

        shifts.forEach((s, idx) => {
            const card = document.getElementById(`emp-card-${idx}`);
            if (!card) return;

            card.classList.remove('card-active', 'card-over', 'card-future');
            const bar = document.getElementById(`shift-bar-${idx}`);
            if (bar) bar.classList.remove('bar-over');

            if (currentOffset === 9999) {
                card.classList.add('card-over');
                if (bar) bar.classList.add('bar-over');
                return;
            }
            if (currentOffset === -1) {
                return; 
            }

            const meta = calculateShiftMeta(s);
            if (currentOffset >= meta.start && currentOffset < meta.end) {
                card.classList.add('card-active');
            } else if (currentOffset >= meta.end) {
                card.classList.add('card-over');
                if (bar) bar.classList.add('bar-over');
            }
        });
    }

    function timeToOffset(timeStr) {
        if (!timeStr) return null;
        let clean = timeStr.replace(':', ''); let h = parseInt(clean.substring(0, 2)); let m = parseInt(clean.substring(2, 4));
        let mins = (h * 60) + m; let rel = mins - (START_HOUR * 60); if (rel < 0) rel += (24 * 60); return rel;
    }
    function normalizeTime(t) {
        if (!t) return '';
        t = t.trim(); if (t.includes(':')) return t;
        if (t.length === 4) return `${t.substring(0,2)}:${t.substring(2,4)}`;
        if (t.length === 3) return `0${t.substring(0,1)}:${t.substring(1,3)}`;
        if (t.length === 1 || t.length === 2) return `${t.padStart(2,'0')}:00`;
        return '';
    }
    function parseRangeStr(str) {
        if(!str || !str.trim()) return { start: '', end: '' };
        let parts = str.split(/[-‚Äìto\s]+/).filter(x => x);
        if(parts.length < 2) return { start: '', end: '' };
        return { start: normalizeTime(parts[0]), end: normalizeTime(parts[1]) };
    }
    
    // Updated robust getOverlap
    function getOverlap(start1, end1, start2, end2) {
        if (start1 == null || end1 == null) return 0;
        let s = Math.max(start1, start2);
        let e = Math.min(end1, end2);
        return Math.max(0, e - s);
    }

    function calculateShiftMeta(shift) {
        const startOffset = timeToOffset(shift.start); const endOffset = timeToOffset(shift.end);
        let duration = endOffset - startOffset; if (duration < 0) duration += (24 * 60); 
        
        let yEndMins = endOffset; 
        let yStartMins = endOffset - 60; 

        // Check multiple leave ranges for yellow bar logic
        if (shift.leaveRanges && shift.leaveRanges.length > 0) {
            shift.leaveRanges.forEach(r => {
                const ls = timeToOffset(r.start); 
                const le = timeToOffset(r.end);
                let diff = endOffset - le; if (diff < -1000) diff += 1440; 
                // If this leave block ends within 30 mins of shift end, it truncates the shift visual
                if (Math.abs(diff) <= 30) { yEndMins = ls; yStartMins = ls - 60; }
            });
        }
        return { start: startOffset, end: startOffset + duration, yStart: yStartMins, yEnd: yEndMins };
    }

    function createBarElement(startStr, endStr, className, initials, timesLabel) {
        if(!startStr || !endStr) return null;
        const startOffset = timeToOffset(startStr); const endOffset = timeToOffset(endStr);
        let duration = endOffset - startOffset; if (duration < 0) duration += (24 * 60); 
        const leftPct = (startOffset / TOTAL_MINUTES) * 100; const widthPct = (duration / TOTAL_MINUTES) * 100;
        const el = document.createElement('div'); el.className = `bar-segment ${className}`;
        el.style.left = `${leftPct}%`; el.style.width = `${widthPct}%`;
        if (initials) el.innerHTML = `<span class="bar-text-container"><span class="bar-initials">${initials}</span><span class="bar-times">${timesLabel}</span></span>`;
        return el;
    }
    function getSortedIndices() {
        let sorted = []; let added = new Set(); let traineesByTrainer = {};
        shifts.forEach((s, idx) => { if(s.assignedTrainer) { if(!traineesByTrainer[s.assignedTrainer]) traineesByTrainer[s.assignedTrainer] = []; traineesByTrainer[s.assignedTrainer].push(idx); } });
        let indices = shifts.map((_, i) => i);
        indices.sort((a, b) => {
            const startA = timeToOffset(shifts[a].start);
            const startB = timeToOffset(shifts[b].start);
            if (startA !== startB) return startA - startB;
            return shifts[a].name.localeCompare(shifts[b].name);
        });

        indices.forEach((idx) => {
            if (added.has(idx)) return; 
            const s = shifts[idx];
            if (s.assignedTrainer && shifts.some(p => p.name === s.assignedTrainer && !p._hidden)) { return; }

            sorted.push(idx); added.add(idx);

            if (traineesByTrainer[s.name]) {
                traineesByTrainer[s.name].forEach(childIdx => {
                    if (!added.has(childIdx)) { sorted.push(childIdx); added.add(childIdx); }
                });
            }
        });
        return sorted;
    }

    // --- ADDED: SHIFT STATS LOGIC ---
    function updateShiftStats() {
        let dayCount = 0;
        let eveCount = 0;
        
        let [y, m, d] = currentDate.split('-').map(Number);
        let currentDayObj = new Date(y, m - 1, d);
        let dayOfWeek = currentDayObj.getDay(); // 0=Sun, 6=Sat

        // DOM Elements
        const dayEl = document.querySelector('.stat-box.day');
        const eveEl = document.querySelector('.stat-box.eve');

        // Reset classes
        dayEl.className = 'stat-box day';
        eveEl.className = 'stat-box eve';

        shifts.forEach(s => {
            if(s._hidden) return;

            let isTrainee = s.type === 'trainee' || trainees.includes(s.name);
            if (s.isStaffing) isTrainee = false; 
            if (isTrainee) return;

            // Exclude 20:00+ starts if any slipped in
            let hStart = parseInt(s.start.substring(0,2));
            if (hStart >= 20) return;

            let meta = calculateShiftMeta(s);
            // 19:00 relative to 04:00 is (19-4)*60 = 900 minutes.
            if (meta.end >= 900) {
                eveCount++;
            } else {
                dayCount++;
            }
        });

        // Day Logic (Sun-Sat): <= 6 Red, == 7 Yellow
        if (dayCount <= 6) dayEl.classList.add('stat-danger');
        else if (dayCount === 7) dayEl.classList.add('stat-warning');

        // Eve Logic
        if (dayOfWeek === 6) { // Saturday: <= 6 Red, == 7 Yellow
            if (eveCount <= 6) eveEl.classList.add('stat-danger');
            else if (eveCount === 7) eveEl.classList.add('stat-warning');
        } else { // Sun-Fri: <= 7 Red, == 8 Yellow
            if (eveCount <= 7) eveEl.classList.add('stat-danger');
            else if (eveCount === 8) eveEl.classList.add('stat-warning');
        }

        dayEl.innerText = `Day: ${dayCount}`;
        eveEl.innerText = `Eve: ${eveCount}`;
    }

    function render() {
        const graphBody = document.getElementById('graphBody'); const listBody = document.getElementById('employeeList');
        graphBody.innerHTML = ''; listBody.innerHTML = '';
        const displayOrder = getSortedIndices();
        displayOrder.forEach(index => {
            const shift = shifts[index];
            if (shift._hidden) return; 

            let isTrainee = shift.type === 'trainee' || trainees.includes(shift.name); if (shift.isStaffing) isTrainee = false;
            let meta = calculateShiftMeta(shift);
            let duration = meta.end - meta.start;
            let durationHours = (duration / 60).toFixed(1).replace('.0', '');
            
            const row = document.createElement('div'); row.className = 'shift-row';
            let workStart = meta.start; let workEnd = meta.end;
            
            // Calc Work Start/End based on last Leave range (Simplification for visual text alignment)
            // Ideally we'd scan all ranges, but for text alignment we usually care about the "main" gap.
            // Keeping mostly standard for text position unless specific range abuts.
            // (Full multiple-leave gap calculation for text-centering is complex, sticking to base duration is usually fine)
            
            let workDuration = workEnd - workStart;
            let textLeftPct = ((workStart - meta.start) / duration) * 100; let textWidthPct = (workDuration / duration) * 100;
            const barWidthPct = (duration / TOTAL_MINUTES) * 100; const barLeftPct = (meta.start / TOTAL_MINUTES) * 100;
            
            let displayName = shift.name; if (shift.isCic) displayName += " (CIC)";
            let timeLabel = `${shift.start}-${shift.end} ${durationHours}h`;

            const mainBar = document.createElement('div'); mainBar.className = `bar-segment shift-bar ${isTrainee ? 'trainee' : ''}`;
            mainBar.id = `shift-bar-${index}`; // Unique ID for shading
            if (shift._previewing) mainBar.classList.add('preview-highlight');
            mainBar.style.left = `${barLeftPct}%`; mainBar.style.width = `${barWidthPct}%`;
            mainBar.onclick = () => openEditModal(index); mainBar.title = `${displayName} ${timeLabel}`;
            
            let yellowHtml = '';
            if (!isTrainee && meta.end < 1110) { 
                const relativeYellowLeft = ((meta.yStart - meta.start) / duration) * 100; const relativeYellowWidth = (60 / duration) * 100;
                yellowHtml = `<div class="last-hour-indicator" style="left: ${relativeYellowLeft}%; width: ${relativeYellowWidth}%;"></div>`;
            }
            let stripeHtml = '';
            shifts.forEach(traineeShift => {
                if(traineeShift.assignedTrainer === shift.name) {
                    let tMeta = calculateShiftMeta(traineeShift); let overlap = getOverlap(meta.start, meta.end, tMeta.start, tMeta.end);
                    if(overlap > 0) { let oStart = Math.max(meta.start, tMeta.start); let oLeft = ((oStart - meta.start) / duration) * 100; let oWidth = (overlap / duration) * 100; stripeHtml += `<div class="training-overlap-indicator" style="left: ${oLeft}%; width: ${oWidth}%;"></div>`; }
                }
            });
            
            // PRE-DUTY WX BADGE LOGIC
            let wxHtml = '';
            if (shift.preDutyWx) {
                let wxLeftPct = 0;
                if (workStart > meta.start) {
                    wxLeftPct = ((workStart - meta.start) / duration) * 100;
                }
                wxHtml = `<div class="wx-badge" style="left: calc(${wxLeftPct}% + 4px)"><span style="color:#4ade80; margin-right:2px;">‚úì</span> WX</div>`;
            }

            mainBar.innerHTML = `${wxHtml}<span class="bar-text-container" style="left: ${textLeftPct}%; width: ${textWidthPct}%;"><span class="bar-initials">${displayName}</span><span class="bar-times">${timeLabel}</span></span>${yellowHtml}${stripeHtml}`;
            row.appendChild(mainBar);

            // RENDER MULTIPLE LEAVE BARS
            if (shift.leaveRanges && shift.leaveRanges.length > 0) {
                shift.leaveRanges.forEach(r => {
                    const lb = createBarElement(r.start, r.end, 'leave-bar', 'LV', `${r.start}-${r.end}`);
                    if(lb) { 
                        if (shift._previewing) lb.classList.add('preview-highlight'); 
                        lb.onclick = () => openEditModal(index); 
                        row.appendChild(lb); 
                    }
                });
            }

            // RENDER MULTIPLE TOS BARS
            if (shift.tosRanges && shift.tosRanges.length > 0) {
                shift.tosRanges.forEach(r => {
                    const tb = createBarElement(r.start, r.end, 'tos-bar', 'TOS', `${r.start}-${r.end}`);
                    if(tb) { 
                        tb.onclick = () => openEditModal(index); 
                        row.appendChild(tb); 
                    }
                });
            }
            
            graphBody.appendChild(row);
        });

        // --- SEPARATE LOOP FOR EMPLOYEE LIST ---
        shifts.forEach((shift, index) => {
            if (shift._hidden) return; 

            let isTrainee = shift.type === 'trainee' || trainees.includes(shift.name);
            
            let duration = calculateShiftMeta(shift).end - calculateShiftMeta(shift).start;
            let durationHours = (duration / 60).toFixed(1).replace('.0', '');

            let extraTags = '';
            if (shift.leaveRanges) {
                shift.leaveRanges.forEach(r => { extraTags += `<span class="tag-badge tag-leave">LV ${r.start}-${r.end}</span>`; });
            }
            if (shift.tosRanges) {
                shift.tosRanges.forEach(r => { extraTags += `<span class="tag-badge tag-tos">TOS ${r.start}-${r.end}</span>`; });
            }
            
            let notesHtml = shift.notes ? `<div class="emp-notes">üìù ${shift.notes}</div>` : '';

            // --- TRAINER DROPDOWN GENERATION ---
            let trainerSelectHtml = '';
            if (isTrainee) {
                const activeTrainers = trainers.filter(t => {
                    const isOnShift = shifts.some(s => s.name === t && !s._hidden); 
                    return isOnShift || t === shift.assignedTrainer;
                });

                trainerSelectHtml = `<select class="trainer-dropdown" onchange="quickAssignTrainer(${index}, this.value)" onclick="event.stopPropagation()">`;
                trainerSelectHtml += `<option value="">Assign Trainer...</option>`;
                activeTrainers.forEach(t => {
                    const selected = shift.assignedTrainer === t ? 'selected' : '';
                    trainerSelectHtml += `<option value="${t}" ${selected}>${t}</option>`;
                });
                trainerSelectHtml += `</select>`;
            }

            const card = document.createElement('div'); card.className = `employee-card ${isTrainee ? 'trainee-card' : ''}`;
            card.id = `emp-card-${index}`; 
            
            card.innerHTML = `
                <div class="emp-info">
                    <div class="emp-name">${shift.name} ${shift.isCic ? '<span class="cic-tag">CIC</span>' : ''}</div>
                    <div class="emp-time">${shift.start} - ${shift.end} (${durationHours}h)</div>
                    ${trainerSelectHtml}
                    ${notesHtml}${extraTags ? `<div class="tag-row">${extraTags}</div>` : ''}
                </div>
                <div class="emp-actions">
                    <button class="btn-icon btn-edit" onclick="openEditModal(${index})">Edit</button>
                    <button class="btn-icon btn-del" onclick="deleteShift(${index})">X</button>
                </div>
            `;
            listBody.appendChild(card);
        });
        updateStaffCounts();
        updateShiftStats(); 
        updateCurrentTime(); 
    }

    function quickAssignTrainer(index, trainerName) {
        pushHistory();
        shifts[index].assignedTrainer = trainerName;
        saveData(false);
        render(); 
    }

    function updateStaffCounts() {
        for (let i = 0; i < 24; i++) {
            let hourStart = i * 60;
            let hourEnd = hourStart + 60;
            let count = 0;
            
            let actualHour = (START_HOUR + i) % 24;

            shifts.forEach(s => {
                if (s._hidden) return; 
                
                if (s.isCic) {
                    const isMidShift = (actualHour >= 22) || (actualHour < 5);
                    if (!isMidShift) return; 
                }

                let isTrainee = s.type === 'trainee' || trainees.includes(s.name);
                if (isTrainee) return;
                
                if (!s.isStaffing) return;

                let minutesPresent = 0;

                let start = timeToOffset(s.start);
                let end = timeToOffset(s.end);

                let effectiveEnd = end;
                if (start >= 60 && end <= 1020) {
                    effectiveEnd = end - 60; 
                }

                let mainOverlap = getOverlap(start, effectiveEnd, hourStart, hourEnd);

                // Subtract ALL Leave Ranges
                if (s.leaveRanges) {
                    s.leaveRanges.forEach(r => {
                        let ls = timeToOffset(r.start);
                        let le = timeToOffset(r.end);
                        let leaveOverlap = getOverlap(ls, le, hourStart, hourEnd);
                        mainOverlap -= leaveOverlap;
                    });
                }

                if (mainOverlap > 0) minutesPresent += mainOverlap;

                // Add ALL TOS Ranges
                if (s.tosRanges) {
                    s.tosRanges.forEach(r => {
                        let ts = timeToOffset(r.start);
                        let te = timeToOffset(r.end);
                        let tosOverlap = getOverlap(ts, te, hourStart, hourEnd);
                        minutesPresent += tosOverlap;
                    });
                }

                if (minutesPresent >= 30) {
                    count++;
                }
            });

            const el = document.getElementById('count-' + i);
            if (el) {
                el.innerText = count;
                el.className = 'count-label'; 
                el.style.backgroundColor = '';
                el.style.color = count > 0 ? '#3b82f6' : '#ccc';

                let [y, m, d] = currentDate.split('-').map(Number);
                let day = new Date(y, m-1, d).getDay(); 

                if (day !== 6) { 
                    if (actualHour === 6) { if (count < 4) el.classList.add('count-bad'); else el.classList.add('count-good'); } 
                    else if (actualHour >= 7 && actualHour < 20) { if (count === 6) el.classList.add('count-warning'); else if (count <= 5) el.classList.add('count-bad'); }
                    else if (actualHour === 20) { if (count < 8) el.classList.add('count-bad'); else el.classList.add('count-good'); } 
                    else if (actualHour === 21) { if (count < 5) el.classList.add('count-bad'); else el.classList.add('count-good'); } 
                    else if (actualHour === 22) { if (count < 3) el.classList.add('count-bad'); else el.classList.add('count-good'); }
                } else { 
                    if (actualHour >= 7 && actualHour < 20) { if (count === 6) el.classList.add('count-warning'); else if (count <= 5) el.classList.add('count-bad'); }
                    else if (actualHour === 21) { if (count < 5) el.classList.add('count-bad'); else el.classList.add('count-good'); }
                }
            }
        }
    }

    // --- MIGRATION ON LOAD ---
    function loadData() { 
        const stored = localStorage.getItem('shifts_' + currentDate); 
        if (stored) {
            shifts = JSON.parse(stored);
            // MIGRATION: Convert old single-fields to arrays
            shifts.forEach(s => {
                if (!s.leaveRanges) s.leaveRanges = [];
                if (s.leaveStart && s.leaveEnd) {
                    s.leaveRanges.push({start: s.leaveStart, end: s.leaveEnd});
                    delete s.leaveStart; delete s.leaveEnd;
                }
                if (!s.tosRanges) s.tosRanges = [];
                if (s.tosStart && s.tosEnd) {
                    s.tosRanges.push({start: s.tosStart, end: s.tosEnd});
                    delete s.tosStart; delete s.tosEnd;
                }
            });
        } else {
            shifts = [];
        }
        render(); 
    }
    
    function saveData(pushHist = true) { 
        if (pushHist) pushHistory();
        localStorage.setItem('shifts_' + currentDate, JSON.stringify(shifts)); 
        render(); 
    }
    
    function deleteShift(index) { if(confirm('Delete?')) { pushHistory(); shifts.splice(index, 1); saveData(false); } }
    
    function clearData() {
        if(confirm('Clear all data for this day?')) {
            pushHistory(); 
            shifts = [];
            saveData(false);

            requests = [];
            saveRequests();
            renderRequests();
        }
    }

    function openPasteModal() { 
        document.getElementById('pasteModal').style.display = 'flex';
        setTimeout(() => document.getElementById('pasteInput').focus(), 50);
    }

    function openSmartPasteModal() {
        document.getElementById('smartPasteModal').style.display = 'flex';
        setTimeout(() => document.getElementById('smartPasteInput').focus(), 50);
    }
    
    async function initiateSmartPaste() {
        try {
            const text = await navigator.clipboard.readText();
            if (text) {
                processSmartPaste(text);
            } else {
                openSmartPasteModal();
            }
        } catch (err) {
            console.warn('Clipboard read failed:', err);
            openSmartPasteModal();
        }
    }

    function openPreDutyModal() {
        document.getElementById('preDutyModal').style.display = 'flex';
        setTimeout(() => document.getElementById('preDutyInput').focus(), 50);
    }

    function openRequestModal() { document.getElementById('requestModal').style.display = 'flex'; document.getElementById('requestInput').focus(); }
    
    function getPreviousDate(dateStr) {
        let [y, m, d] = dateStr.split('-').map(Number);
        let date = new Date(y, m - 1, d);
        date.setDate(date.getDate() - 1);
        let ny = date.getFullYear();
        let nm = String(date.getMonth() + 1).padStart(2, '0');
        let nd = String(date.getDate()).padStart(2, '0');
        return `${ny}-${nm}-${nd}`;
    }

    function addShiftToStorage(dateStr, newShift) {
        let key = 'shifts_' + dateStr;
        let stored = localStorage.getItem(key);
        let dayShifts = stored ? JSON.parse(stored) : [];
        let exists = dayShifts.some(s => s.name === newShift.name && s.start === newShift.start);
        if (!exists) {
            dayShifts.push(newShift);
            localStorage.setItem(key, JSON.stringify(dayShifts));
        }
    }

    function addShift(name, start, end, type, isCic, isStaffing = false, forceKeep = false) {
        if (!name) return;
        
        let newShift = { name, start, end, type, isCic, isStaffing, notes: '', leaveRanges: [], tosRanges: [], preDutyWx: false };

        let exists = shifts.some(s => s.name === name && s.start === start);
        if (exists) return;

        let h = parseInt(start.substring(0, 2));
        if (h >= 20 && !forceKeep) {
            let prevDate = getPreviousDate(currentDate);
            addShiftToStorage(prevDate, newShift);
        } else {
            shifts.push(newShift);
        }
    }
    
    function processPaste(manualContent) {
        let text = manualContent || document.getElementById('smartPasteInput').value; 
        if(!text.trim()) text = document.getElementById('pasteInput').value; 

        if (text.includes('===REQUESTS_START===')) {
            const parts = text.split('===REQUESTS_START===');
            processRequests(parts[1]); 
            text = parts[0]; 
        }
        
        text = text.replace('===SCHEDULE_START===', '').trim();
        text = text.replace(/(\d+\s+of\s+\d+)(\d{3,4})/g, "$1\n$2"); 

        const timeHeaderRegex = /^(\d{4})(-?(\d{1,2}))?$/;
        let lines = text.split(/\n/);
        let currentBlock = null;
        let blocks = [];

        for (let i = 0; i < lines.length; i++) {
            let line = lines[i].trim();
            let match = line.match(timeHeaderRegex);
            if (match) {
                if (currentBlock) blocks.push(currentBlock);
                let t = match[1]; 
                let h = parseInt(t.substring(0, 2)); 
                let m = parseInt(t.substring(2, 4));
                let dur = 8;
                if (match[3]) dur = parseInt(match[3]); 
                let eH = (h + dur) % 24;
                currentBlock = {
                    shift: { 
                        start: `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`, 
                        end: `${String(eH).padStart(2,'0')}:${String(m).padStart(2,'0')}`, 
                        isCic: false 
                    },
                    dataLines: []
                };
            } else if (currentBlock) {
                currentBlock.dataLines.push(line);
            }
        }
        if (currentBlock) blocks.push(currentBlock);

        if (blocks.length === 0) {
            alert("No valid shifts found in paste data.");
            return;
        }

        pushHistory(); 

        blocks.forEach(blk => {
            let sData = blk.shift;
            let dLines = blk.dataLines; 
            
            if (dLines[0]) {
                dLines[0].split(/[\s,\t]+/).forEach(n => {
                    let cleanName = n.replace(/[$]/g, '').trim();
                    if (!cleanName || cleanName === '-') return;

                    if (cleanName && cleanName !== "-") {
                        let isCic = sData.isCic; let name = cleanName;
                        if (name.includes('(') && name.includes(')')) { isCic = true; name = name.replace(/[()]/g, ''); }
                        
                        let existing = shifts.find(x => x.name === name && !x._hidden);
                        let isDoubleShift = false;
                        if (existing) {
                            let eEnd = timeToOffset(existing.end);
                            let eStart = timeToOffset(existing.start);
                            let dur = eEnd - eStart; if(dur < 0) dur += 1440;
                            let actualEnd = eStart + dur;
                            let nStart = timeToOffset(sData.start);
                            let gap = nStart - actualEnd; 
                            if (gap < 0) gap += 1440; 
                            if (gap >= 600) isDoubleShift = true;
                        }

                        if (isDoubleShift) {
                            addShift(name, sData.start, sData.end, 'standard', isCic, true, true);
                        } else {
                            let idx = shifts.findIndex(x => x.name === name && !x._hidden);
                            if (idx !== -1) {
                                 let oldH = parseInt(sData.start.substring(0,2));
                                 if (oldH >= 20) {
                                     let s = shifts[idx];
                                     let up = {...s, start: sData.start, end: sData.end, isCic: (isCic || s.isCic)};
                                     shifts.splice(idx, 1);
                                     let pd = getPreviousDate(currentDate); addShiftToStorage(pd, up);
                                 } else {
                                     shifts[idx].start = sData.start; 
                                     shifts[idx].end = sData.end;
                                     shifts[idx].isCic = (isCic || shifts[idx].isCic);
                                 }
                            } else {
                                addShift(name, sData.start, sData.end, 'standard', isCic, true);
                            }
                        }
                    }
                });
            }

            if (dLines[1]) {
                dLines[1].split(/[\s,\t]+/).forEach(n => {
                    let cleanName = n.replace(/[$]/g, '').trim();
                    if (!cleanName || cleanName === '-') return;

                    if (cleanName && cleanName !== "-") {
                        let name = cleanName.replace(/[()]/g, ''); 
                        let idx = shifts.findIndex(x => x.name === name && !x._hidden);
                        if (idx !== -1) {
                             let oldH = parseInt(sData.start.substring(0,2));
                             if (oldH >= 20) {
                                 let s = shifts[idx];
                                 let up = {...s, start: sData.start, end: sData.end, isCic: true};
                                 shifts.splice(idx, 1);
                                 let pd = getPreviousDate(currentDate); addShiftToStorage(pd, up);
                             } else {
                                 shifts[idx].start = sData.start; 
                                 shifts[idx].end = sData.end;
                                 shifts[idx].isCic = true;
                             }
                        } else {
                            addShift(name, sData.start, sData.end, 'standard', true, false);
                        }
                    }
                });
            }

            if (dLines[2]) {
                dLines[2].split(/[\s,\t]+/).forEach(n => {
                    let cleanName = n.replace(/[$]/g, '').trim();
                    if (!cleanName || cleanName === '-') return;

                    if (cleanName && cleanName !== "-") {
                        let idx = shifts.findIndex(x => x.name === cleanName && !x._hidden);
                        if (idx !== -1) {
                             let oldH = parseInt(sData.start.substring(0,2));
                             if (oldH >= 20) {
                                 let s = shifts[idx];
                                 let up = {...s, start: sData.start, end: sData.end};
                                 shifts.splice(idx, 1);
                                 let pd = getPreviousDate(currentDate); addShiftToStorage(pd, up);
                             } else {
                                 shifts[idx].start = sData.start; 
                                 shifts[idx].end = sData.end;
                             }
                        } else {
                            addShift(cleanName, sData.start, sData.end, 'trainee', false, false);
                        }
                    }
                });
            }
        });

        if(!manualContent) { 
            saveData(false); 
            closeModal('smartPasteModal'); 
            document.getElementById('smartPasteInput').value = ''; 
        } else { 
            saveData(false); 
            loadData(); 
            closeModal('smartPasteModal'); 
            document.getElementById('smartPasteInput').value = '';
        }
    }
    
    function processPreDuty(manualContent) {
        const text = manualContent || document.getElementById('preDutyInput').value;
        const tokens = text.split(/[\s,]+/);
        pushHistory(); 
        tokens.forEach(token => {
            let clean = token.trim();
            if (clean.length === 3 && clean.startsWith('8')) { clean = clean.substring(1); }
            if (/^[a-zA-Z]{2}$/.test(clean)) {
                const initials = clean.toUpperCase();
                shifts.forEach(s => { if (s.name.toUpperCase() === initials) { s.preDutyWx = true; } });
            }
        });
        if(!manualContent) {
            saveData(false);
            closeModal('preDutyModal');
            document.getElementById('preDutyInput').value = '';
        }
    }

    function processRequests(manualContent) {
        const text = manualContent || document.getElementById('requestInput').value; 
        const lines = text.split(/\n/);
        let changesMade = false;
        let snapshotNeeded = false;

        lines.forEach(line => {
            if (!line.trim()) return;
            let cols = line.split(/\t/);
            if (cols.length < 5) cols = line.split(/\s{2,}/);
            if (cols.length < 5) cols = line.split(/\s+/);

            let statusIndex = -1;
            for (let i = 4; i < cols.length; i++) {
                if (cols[i] && /Approved|Pending|Denied/i.test(cols[i])) { statusIndex = i; break; }
            }
            if (statusIndex === -1) return; 

            let cpcRaw = cols[0].trim();
            let cpc = cpcRaw.replace(/[$]/g, '').trim();

            const status = cols[statusIndex].trim();
            let typeRaw = cols[1].trim();
            let from, to;
            if (cols[1] === 'Shift' && cols[2] === 'Chg') {
                typeRaw = "Shift Chg"; from = cols[3] ? cols[3].trim() : ''; to = cols[4] ? cols[4].trim() : '';
            } else {
                from = cols[2] ? cols[2].trim() : ''; to = cols[3] ? cols[3].trim() : '';
            }
            
            let cleanFrom = from; if (cleanFrom.toLowerCase() !== 'shift') cleanFrom = cleanFrom.replace(/f/gi, '');
            let cleanTo = to; if (cleanTo.toLowerCase() !== 'shift') cleanTo = cleanTo.replace(/f/gi, '');
            
            const isLeave = ['Annual', 'Sick', 'Holiday', 'XTU', 'Admin', 'Furlough'].some(t => typeRaw.toLowerCase().includes(t.toLowerCase()));
            const isShiftChg = typeRaw.toLowerCase().includes('shift chg');
            const isTos = ['XTE', 'CTE', 'OT'].some(t => typeRaw.toUpperCase().includes(t)); 
            const isApproved = status.toLowerCase().includes('approved');
            const isPendingOrDenied = status.toLowerCase().includes('pending') || status.toLowerCase().includes('denied');
            
            if (isApproved) {
                let updateTargetIdx = -1;
                if (isShiftChg) {
                    const idx = shifts.findIndex(s => s.name === cpc);
                    if (idx !== -1) {
                        if (!snapshotNeeded) { pushHistory(); snapshotNeeded = true; }
                        let p = parseShiftStringForPreview(to);
                        if (p) {
                            let h = parseInt(p.start.substring(0,2));
                            if (h >= 20) {
                                const shiftToMove = { ...shifts[idx], start: p.start, end: p.end, isCic: p.isCic };
                                shifts.splice(idx, 1); 
                                let prevDate = getPreviousDate(currentDate);
                                addShiftToStorage(prevDate, shiftToMove);
                                changesMade = true;
                            } else {
                                shifts[idx].start = p.start;
                                shifts[idx].end = p.end;
                                shifts[idx].isCic = p.isCic;
                                changesMade = true;
                            }
                        }
                    }
                    return; 
                }

                const idx = shifts.findIndex(s => s.name === cpc);
                if (idx !== -1) {
                    if (!snapshotNeeded) { pushHistory(); snapshotNeeded = true; } 
                    
                    if (isTos) {
                        if(!shifts[idx].tosRanges) shifts[idx].tosRanges = [];
                        shifts[idx].tosRanges.push({start: normalizeTime(cleanFrom), end: normalizeTime(cleanTo)});
                        changesMade = true;
                    }
                    else if (isLeave) {
                        if (cleanFrom.toLowerCase() !== 'shift') {
                            if(!shifts[idx].leaveRanges) shifts[idx].leaveRanges = [];
                            shifts[idx].leaveRanges.push({start: normalizeTime(cleanFrom), end: normalizeTime(cleanTo)});
                            changesMade = true;
                        }
                    } 
                }
                return; 
            }

            if (isPendingOrDenied) {
                let details = '';
                if (isShiftChg) { if(cleanFrom) details = `(${cleanFrom} -> ${cleanTo})`; } else { if (cleanFrom.toLowerCase() !== 'shift') details = `(${cleanFrom}-${cleanTo})`; }
                const newReq = { cpc: cpc, type: typeRaw, details: details, status: status, isShiftChg: isShiftChg, cleanFrom: cleanFrom, cleanTo: cleanTo };
                const isDuplicate = requests.some(r => r.cpc === newReq.cpc && r.type === newReq.type && r.details === newReq.details && r.status === newReq.status);
                if (!isDuplicate) { requests.push(newReq); }
            }
        });
        
        saveRequests();
        renderRequests();
        if (changesMade) {
            saveData(false); 
            render();
        }
        if(!manualContent) {
            closeModal('requestModal'); 
            document.getElementById('requestInput').value = '';
        }
    }

    function processSmartPaste(manualContent) {
        const raw = manualContent || document.getElementById('smartPasteInput').value;
        if (!raw.trim()) return;
        pushHistory(); 
        if (raw.includes('===SCHEDULE_START===')) {
            const parts = raw.split(/===[A-Z_]+===/); 
            if (parts[1]) processPaste(parts[1]);
            if (parts[2]) processRequests(parts[2]);
        } 
        else {
            if (raw.includes('AMAREA') || /8[a-zA-Z]{2}/.test(raw)) {
                processPreDuty(raw);
            } else if (raw.includes('\t') && (raw.includes('Approved') || raw.includes('Pending'))) {
                processRequests(raw);
            } else {
                processPaste(raw);
            }
        }
        saveData(false);
        closeModal('smartPasteModal');
        document.getElementById('smartPasteInput').value = '';
    }

    function toggleRequestPreview(li, cpc, isShiftChange, fromStr, toStr, isTos) {
        let idx = shifts.findIndex(s => s.name === cpc);
        if (previewTimers.has(cpc)) { clearTimeout(previewTimers.get(cpc)); previewTimers.delete(cpc); }

        if (li.classList.contains('active-preview')) {
            if (previewBackups.has(cpc)) { 
                if (idx !== -1) { shifts[idx] = previewBackups.get(cpc); } 
                else { shifts.push(previewBackups.get(cpc)); }
                previewBackups.delete(cpc); 
            } 
            else if (idx !== -1 && shifts[idx]._isNewPreview) { shifts.splice(idx, 1); }
            li.classList.remove('active-preview'); 
            render();
        } else {
            if (idx === -1) {
                if (!toStr) { alert('Cannot create new shift: No time provided.'); return; }
                let p = parseShiftStringForPreview(toStr);
                if (!p) { alert('Cannot create new shift: Invalid time ' + toStr); return; }
                addShift(cpc, p.start, p.end, 'standard', false);
                idx = shifts.length - 1; 
                shifts[idx]._isNewPreview = true;
            } else { 
                previewBackups.set(cpc, JSON.parse(JSON.stringify(shifts[idx]))); 
            }
            
            li.classList.add('active-preview'); 
            const s = shifts[idx]; 
            s._previewing = true; 
            
            let isFullLeave = (!isShiftChange && fromStr.toLowerCase() === 'shift');

            if (isShiftChange) { 
                if (toStr.toUpperCase() === 'X') { s._hidden = true; } 
                else {
                    let p = parseShiftStringForPreview(toStr); 
                    if (p) { s.start = p.start; s.end = p.end; s.isCic = p.isCic; } 
                }
            } 
            else { 
                if (isTos) {
                    if(!s.tosRanges) s.tosRanges = [];
                    s.tosRanges.push({start: normalizeTime(fromStr), end: normalizeTime(toStr)});
                } else {
                    if (isFullLeave) { s.leaveRanges = [{start: s.start, end: s.end}]; } 
                    else { 
                        if(!s.leaveRanges) s.leaveRanges = [];
                        s.leaveRanges.push({start: normalizeTime(fromStr), end: normalizeTime(toStr)});
                    } 
                }
            }
            render(); 
            const timerId = setTimeout(() => { 
                const current = shifts.find(item => item.name === cpc);
                if(current) {
                    delete current._previewing;
                    if(isFullLeave) current._hidden = true; 
                    render();
                }
                previewTimers.delete(cpc); 
            }, 5000);
            previewTimers.set(cpc, timerId);
        }
    }

    function parseShiftStringForPreview(str) {
        if (!str) return null;
        if (/^[tT]/.test(str)) str = str.substring(1);
        let isCic = false;
        if (/^[cC]/.test(str)) { isCic = true; str = str.substring(1); }
        let clean = str.replace(/f/gi, '');
        let parts = clean.split('-');
        let start = normalizeTime(parts[0]);
        let end = '';
        if (parts.length > 1) { 
            let p2 = parts[1].trim();
            if (p2.length <= 2) {
                let durHours = parseInt(p2); let h = parseInt(start.substring(0,2)); let m = parseInt(start.substring(3,5));
                let endH = (h + durHours) % 24; end = `${String(endH).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
            } else { end = normalizeTime(p2); }
        } 
        else {
            let h = parseInt(start.substring(0,2)); let m = parseInt(start.substring(3,5));
            let endH = (h + 8) % 24; end = `${String(endH).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
        }
        return { start, end, isCic };
    }

    function closeModal(id) { document.getElementById(id).style.display = 'none'; }
    function openEditModal(index) {
        const s = shifts[index]; document.getElementById('editId').value = index; document.getElementById('editName').value = s.name;
        document.getElementById('editStart').value = s.start.replace(':', ''); 
        document.getElementById('editNotes').value = s.notes || ''; document.getElementById('editStaffing').checked = s.isStaffing || false;
        document.getElementById('editPreDutyWx').checked = s.preDutyWx || false;
        
        let sMins = timeToOffset(s.start);
        let eMins = timeToOffset(s.end);
        let diff = eMins - sMins;
        if (diff < 0) diff += 1440;
        document.getElementById('editDuration').value = Number((diff / 60).toFixed(2));
        
        document.getElementById('editLeaveRange').value = ''; 
        document.getElementById('previewLeave').innerHTML = '';
        if (s.leaveRanges) {
            s.leaveRanges.forEach(r => addTag(`${r.start}-${r.end}`, 'leave', false));
        }

        document.getElementById('editTosRange').value = '';
        document.getElementById('previewTos').innerHTML = '';
        if (s.tosRanges) {
            s.tosRanges.forEach(r => addTag(`${r.start}-${r.end}`, 'tos', false));
        }

        const isTrainee = s.type === 'trainee' || trainees.includes(s.name);
        const wrapper = document.getElementById('staffingCheckboxWrapper'); const trainerWrapper = document.getElementById('trainerSelectWrapper'); const trainerSelect = document.getElementById('editAssignedTrainer');
        if (isTrainee) {
            wrapper.style.display = 'flex'; trainerWrapper.style.display = 'block'; trainerSelect.innerHTML = '<option value="">-- No Trainer --</option>';
            trainers.forEach(t => { const opt = document.createElement('option'); opt.value = t; opt.innerText = t; if(s.assignedTrainer === t) opt.selected = true; trainerSelect.appendChild(opt); });
        } else { wrapper.style.display = 'none'; trainerWrapper.style.display = 'none'; }
        document.getElementById('editModal').style.display = 'flex';
    }
    
    function handleTagKey(event, type) {
        if(event.key === 'Enter') {
            manualAddTag(type);
        }
    }

    function manualAddTag(type) {
        const inputId = type === 'leave' ? 'editLeaveRange' : 'editTosRange';
        const val = document.getElementById(inputId).value;
        if(val.trim()) {
            addTag(val, type, true);
        }
    }

    function addTag(val, type, clearInputBox) {
        const parts = val.split('-');
        if(parts.length < 2) return; 
        const p1 = normalizeTime(parts[0]);
        const p2 = normalizeTime(parts[1]);
        const finalVal = `${p1}-${p2}`;

        const containerId = type === 'leave' ? 'previewLeave' : 'previewTos';
        const container = document.getElementById(containerId);
        
        const className = type === 'leave' ? 'leave' : 'tos'; 
        const label = type === 'leave' ? 'LV' : 'TOS';
        
        const span = document.createElement('span');
        span.className = `modal-tag ${className}`;
        span.setAttribute('data-range', finalVal);
        span.innerHTML = `${label} ${finalVal} <span class="tag-remove" onclick="this.parentElement.remove()">‚úï</span>`;
        container.appendChild(span);

        if(clearInputBox) {
            const inputId = type === 'leave' ? 'editLeaveRange' : 'editTosRange';
            document.getElementById(inputId).value = '';
        }
    }

    function removeTag(containerId) {
        document.getElementById(containerId).innerHTML = '';
    }

    function clearInput(id) { document.getElementById(id).value = ''; }
    
    function saveEdit() {
        pushHistory();
        const idx = document.getElementById('editId').value;
        if (idx !== '') {
            const startVal = normalizeTime(document.getElementById('editStart').value);
            const durVal = parseFloat(document.getElementById('editDuration').value);
            
            if (!startVal || isNaN(durVal)) { alert("Invalid Start Time or Duration"); return; }
   
            let h = parseInt(startVal.substring(0,2));
            let m = parseInt(startVal.substring(3,5));
            let totalStart = (h * 60) + m;
            let totalEnd = totalStart + (durVal * 60);
            
            let eh = Math.floor(totalEnd / 60) % 24;
            let em = Math.round(totalEnd % 60);
            let endVal = `${String(eh).padStart(2,'0')}:${String(em).padStart(2,'0')}`;
   
            let leaveRanges = [];
            document.querySelectorAll('#previewLeave .modal-tag').forEach(t => {
                const parts = t.getAttribute('data-range').split('-');
                leaveRanges.push({start: parts[0], end: parts[1]});
            });

            let tosRanges = [];
            document.querySelectorAll('#previewTos .modal-tag').forEach(t => {
                const parts = t.getAttribute('data-range').split('-');
                tosRanges.push({start: parts[0], end: parts[1]});
            });
            
            if (h >= 20) {
               let s = shifts[idx];
               const newShift = {
                   ...s,
                   start: startVal,
                   end: endVal,
                   notes: document.getElementById('editNotes').value,
                   leaveRanges, tosRanges,
                   isStaffing: document.getElementById('editStaffing').checked,
                   assignedTrainer: document.getElementById('editAssignedTrainer').value,
                   preDutyWx: document.getElementById('editPreDutyWx').checked
               };
               shifts.splice(idx, 1);
               let prevDate = getPreviousDate(currentDate);
               addShiftToStorage(prevDate, newShift);
               saveData(false); 
               closeModal('editModal');
               return;
            }

            shifts[idx] = {
                ...shifts[idx], 
                start: startVal, 
                end: endVal,
                notes: document.getElementById('editNotes').value, 
                leaveRanges, tosRanges,
                isStaffing: document.getElementById('editStaffing').checked, 
                assignedTrainer: document.getElementById('editAssignedTrainer').value,
                preDutyWx: document.getElementById('editPreDutyWx').checked
            };
            saveData(false); closeModal('editModal');
        }
    }
</script>
</body>
</html>
